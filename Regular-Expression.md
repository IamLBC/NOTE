## 语法： 

/正则表达式主体/修饰符(可选)

## 修饰符：

`i`	执行对大小写不敏感的匹配。

`g`	执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。

`m`	执行多行匹配。

## 正则表达式模式
方括号用于查找某个范围内的字符：

`[abc]`	查找方括号之间的任何字符。

`[0-9]`	查找任何从 0 至 9 的数字。

`(x|y)`	查找任何以 | 分隔的选项,类似于 ||

`( ) ` (1). 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰 (2). 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到

元字符是拥有特殊含义的字符：

`.`	查找单个字符,除了换行和行结束符。要匹配包括“\n”在内的任何字符，请使用像“(.|\n)”的模式。

`\w`	查找单词字符。 -- = [0-9a-zA-Z_]

`\W`	查找非单词字符。

`\d`	查找数字。

`\D`	查找非数字字符。

`\s`	查找空白字符。

`\S`	查找非空白字符。

`\b`	匹配单词边界。

`\B`	匹配非单词边界。

`\0`	查找 NULL 字符。

`\n`	查找换行符。

`\f`	查找换页符。

`\r`	查找回车符。

`\t`	查找制表符。

`\v`	查找垂直制表符。

`\xxx`	查找以八进制数 xxx 规定的字符。

`\xdd`	查找以十六进制数 dd 规定的字符。

`\uxxxx`	查找以十六进制数 xxxx 规定的 Unicode 字符。

量词:

`n+`	匹配任何包含至少一个 n 的字符串. = {1,}

`n*`	匹配任何包含零个或多个 n 的字符串。= {0,}

`n?`	匹配任何包含零个或一个 n 的字符串。= {0,1}

`?=n`	匹配任何其后紧接指定字符串 n 的字符串。

`?!n` 匹配任何其后没有紧接指定字符串 n 的字符串。

RegExp 对象方法

`compile`	在 1.5 版本中已废弃。 编译正则表达式。

`exec`	检索字符串中指定的值。返回找到的值,并确定其位置。 -- 返回一个数组,包含第一个被匹配到的索引值,和当前被匹配的字符串,只是能拿到第一个被匹配到的索引,貌似其他没用

`test`	检索字符串中指定的值。返回 true 或 false。

`toString`	返回正则表达式的字符串。

支持正则表达式的 String 对象的方法

`search`	检索与正则表达式相匹配的值。 -- 这个也可以返回第一次被匹配到的索引值

`match`	找到一个或多个正则表达式的匹配。 -- 返回的是一个数组,每一项是匹配到的结果值,前提是要加上修饰符`g`

`replace`	替换与正则表达式匹配的子串。

`split`	把字符串分割为字符串数组。

RegExp 对象属性

`constructor`	返回一个函数,该函数是一个创建 RegExp 对象的原型。

`global`	判断是否设置了 "g" 修饰符

`ignoreCase`	判断是否设置了 "i" 修饰符

`lastIndex`	用于规定下次匹配的起始位置

`multiline`	判断是否设置了 "m" 修饰符

`source`	返回正则表达式的匹配模式

## 进阶
[door1]: http://tool.oschina.net/uploads/apidocs/jquery/regexp.html
[door2]: http://www.regexlab.com/zh/regref.htm
[door3]: https://www.jb51.net/tools/zhengze.html
[door1],[door2],[door2]

`(pattern)`	匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。

`(?:pattern)`	匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。

`(?=pattern)`	正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。

`(?!pattern)`	正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始

`(?<=pattern)` 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?<=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。

`(?<!pattern)` 反向否定预查，与正向否定预查类拟，只是方向相反。例如"(?<!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows"。