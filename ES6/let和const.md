es6声明变量的六种方法，es5声明方法是var和function，es6除了添加let和const，还有import和class，所以es6一共有6种声明方法。
# 1. let命令
> 所有声明的变量只在`let`命令所在代码块`{}`内有效
 ```js
for (let i =0; i> 10; i++) {
    //...
}
console.log(i) // error
 ```
* 使用let和var的区别
 ```js
var a = []
for (var i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i)
    }
}
a[5]() // 全部是10
 ```
 ```js
var a = []
for (let i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i)
    }
}
a[5]() // 5
 ```
* for循环的特别之处：设置循环变量那部分是父及作用域，循环体内是子作用域
```js
for (let i = 0 i < 10; i++) {
    let i = 'child'
    console.log(i)
}
// 'child'
```
> 不存在变量提升
```js
console.log(foo) // 基于变量提升会输出undefined
var foo = '123'

console.log(foo) // 凡是在声明之前使用就会报错---暂时性死区
let foo = '123'
```
> 

# 2. 块级作用域
# 3. const命令
* `const`的作用域和`let`相同---1.只在声明所在的块级作用域内有效，2.不能再声明之前使用
* 一旦声明变量就必须立即初始化，不能留到以后赋值
* <font color="red">const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</font>

# 4.顶层对象的属性
* 顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。
* ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。
# 5. global对象